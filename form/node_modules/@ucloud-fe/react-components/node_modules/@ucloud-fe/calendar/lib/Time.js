"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _react = _interopRequireWildcard(require("react"));

var _classnames = _interopRequireDefault(require("./util/classnames"));

var _useUncontrolled3 = _interopRequireDefault(require("./useUncontrolled"));

var _excluded = ["index", "onStepperClick"],
    _excluded2 = ["value", "defaultValue", "onChange", "mode", "prefixCls", "className", "scrollTo"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var StepperWithoutMemo = function StepperWithoutMemo(_ref) {
  var index = _ref.index,
      onStepperClick = _ref.onStepperClick,
      rest = (0, _objectWithoutProperties2.default)(_ref, _excluded);
  var onClick = (0, _react.useCallback)(function () {
    onStepperClick(index);
  }, [index, onStepperClick]);
  return /*#__PURE__*/_react.default.createElement("div", (0, _extends2.default)({
    onClick: onClick
  }, rest));
};

var Stepper = /*#__PURE__*/(0, _react.memo)(StepperWithoutMemo);
var _uid = 0;

var defaultScrollTo = function defaultScrollTo(element, to) {
  element.scrollTop = to;
};

var ScrollerWithoutMemo = function ScrollerWithoutMemo(_ref2) {
  var _ref2$value = _ref2.value,
      value = _ref2$value === void 0 ? 0 : _ref2$value,
      steps = _ref2.steps,
      onChange = _ref2.onChange,
      prefixCls = _ref2.prefixCls,
      scrollTo = _ref2.scrollTo;

  var _useState = (0, _react.useState)(true),
      _useState2 = (0, _slicedToArray2.default)(_useState, 2),
      scrollLock = _useState2[0],
      setScrollLock = _useState2[1];

  var scroller = (0, _react.useRef)(null);
  var uid = (0, _react.useMemo)(function () {
    return _uid++;
  }, []); // save value into ref

  var valueRef = (0, _react.useRef)(0); // update value from scrollerDOM scrollTop and trigger onChange

  var updateValue = (0, _react.useCallback)(function () {
    var _firstChild$getClient;

    var scrollerDOM = scroller.current;
    if (!scrollerDOM) return;
    var firstChild = scrollerDOM.childNodes[0];
    var rect = (_firstChild$getClient = firstChild.getClientRects()) === null || _firstChild$getClient === void 0 ? void 0 : _firstChild$getClient[0];
    if (!rect) return;
    var childHeight = rect.height;
    var scrollTop = scrollerDOM.scrollTop;
    var currentIndex = Math.round(scrollTop / childHeight);
    onChange === null || onChange === void 0 ? void 0 : onChange(currentIndex);
  }, [onChange]); // update scrollerDom scroll bar to value

  var updateScroll = (0, _react.useCallback)(function (v) {
    var _firstChild$getClient2, _ref3;

    var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
    var scrollerDOM = scroller.current;
    if (!scrollerDOM) return;
    var firstChild = scrollerDOM.childNodes[0];
    var rect = (_firstChild$getClient2 = firstChild.getClientRects()) === null || _firstChild$getClient2 === void 0 ? void 0 : _firstChild$getClient2[0];
    if (!rect) return;
    var childHeight = rect.height;
    if (scrollerDOM.scrollTop === childHeight * v) return false;
    (_ref3 = typeof scrollTo === 'function' ? scrollTo : defaultScrollTo) === null || _ref3 === void 0 ? void 0 : _ref3(scrollerDOM, childHeight * v, duration, uid);
  }, [scrollTo, uid]);
  (0, _react.useEffect)(function () {
    var scrollerDOM = scroller.current;
    if (!scrollerDOM) return;

    var onScroll = function onScroll(e) {
      if (scrollLock) {
        e.preventDefault();
        return false;
      }

      updateValue();
    };

    var onMouseEnter = function onMouseEnter() {
      // unlock scroll
      setScrollLock(false);
    };

    var onMouseLeave = function onMouseLeave() {
      // lock scroll
      setScrollLock(true); // use valueRef value to avoid bind/unbind frequently

      updateScroll(valueRef.current, 0);
    };

    scrollerDOM.addEventListener("scroll", onScroll);
    scrollerDOM.addEventListener('mouseenter', onMouseEnter);
    scrollerDOM.addEventListener('mouseleave', onMouseLeave);
    return function () {
      scrollerDOM.removeEventListener("scroll", onScroll);
      scrollerDOM.removeEventListener('mouseenter', onMouseEnter);
      scrollerDOM.removeEventListener('mouseleave', onMouseLeave);
    };
  }, [updateScroll, updateValue, scrollLock]);
  (0, _react.useEffect)(function () {
    if (valueRef.current === value) return; // update value ref

    valueRef.current = value;
    if (!scrollLock) return; // update scroll when scroll lock and value change

    updateScroll(value);
  }, [updateScroll, value, scrollLock]);
  var onStepperClick = (0, _react.useCallback)(function (index) {
    // scroll to clicked step
    // if return false means click on the same step, force call updateValue
    if (updateScroll(index) === false) {
      updateValue();
    }
  }, [updateScroll, updateValue]);
  var cls = (0, _react.useMemo)(function () {
    return {
      wrap: "".concat(prefixCls, "-wrap"),
      scroller: "".concat(prefixCls, "-scroller"),
      stepper: "".concat(prefixCls, "-stepper"),
      active: "".concat(prefixCls, "-active")
    };
  }, [prefixCls]);
  return /*#__PURE__*/_react.default.createElement("div", {
    className: cls.wrap
  }, /*#__PURE__*/_react.default.createElement("div", {
    ref: scroller,
    className: cls.scroller
  }, steps.map(function (v, i) {
    return /*#__PURE__*/_react.default.createElement(Stepper, {
      key: v,
      index: i,
      onStepperClick: onStepperClick,
      className: (0, _classnames.default)(cls.stepper, value === i && cls.active)
    }, v);
  })));
};

var Scroller = /*#__PURE__*/(0, _react.memo)(ScrollerWithoutMemo);

var padZero = function padZero(v) {
  var s = "00".concat(v);
  return s.substr(s.length - 2);
};

var H = new Array(24).fill(null).map(function (v, i) {
  return i;
});
var HH = H.map(padZero);
var m = new Array(60).fill(null).map(function (v, i) {
  return i;
});
var mm = m.map(padZero);
var s = new Array(60).fill(null).map(function (v, i) {
  return i;
});
var ss = s.map(padZero);
var StepsMap = {
  H: H,
  HH: HH,
  m: m,
  mm: mm,
  s: s,
  ss: ss
};
var TypeMap = {
  H: 'hour',
  HH: 'hour',
  m: 'minute',
  mm: 'minute',
  s: 'second',
  ss: 'second'
};

var Time = function Time(_ref4) {
  var _value = _ref4.value,
      defaultValue = _ref4.defaultValue,
      _onChange = _ref4.onChange,
      _ref4$mode = _ref4.mode,
      mode = _ref4$mode === void 0 ? ['HH', 'mm', 'ss'] : _ref4$mode,
      _ref4$prefixCls = _ref4.prefixCls,
      prefixCls = _ref4$prefixCls === void 0 ? 'zr-time' : _ref4$prefixCls,
      className = _ref4.className,
      scrollTo = _ref4.scrollTo,
      rest = (0, _objectWithoutProperties2.default)(_ref4, _excluded2);
  var d = (0, _react.useMemo)(function () {
    var d = new Date();
    d.setHours(0);
    d.setMinutes(0);
    d.setSeconds(0);
    d.setMilliseconds(0);
    return d;
  }, []);

  var _useUncontrolled = (0, _useUncontrolled3.default)(_value, defaultValue, _onChange),
      _useUncontrolled2 = (0, _slicedToArray2.default)(_useUncontrolled, 2),
      value = _useUncontrolled2[0],
      onChange = _useUncontrolled2[1];

  var stepsArray = (0, _react.useMemo)(function () {
    return mode.map(function (v) {
      return StepsMap[v];
    });
  }, [mode]);
  var valueArray = (0, _react.useMemo)(function () {
    var valueMap;

    if (value == null) {
      valueMap = {
        hour: 0,
        minute: 0,
        second: 0
      };
    } else {
      var date = new Date(value);
      var hour = date.getHours(),
          minute = date.getMinutes(),
          second = date.getSeconds();
      valueMap = {
        hour: hour,
        minute: minute,
        second: second
      };
    }

    return mode.map(function (v) {
      return valueMap[TypeMap[v]];
    });
  }, [value, mode]); // use ref to reduce reRender

  var valueRef = (0, _react.useRef)(value);
  (0, _react.useEffect)(function () {
    valueRef.current = value;
  }, [value]);
  var onHourChange = (0, _react.useCallback)(function (hour) {
    var date = new Date(valueRef.current == null ? d : valueRef.current);
    onChange(new Date(date.setHours(hour)));
  }, [d, onChange]);
  var onMinuteChange = (0, _react.useCallback)(function (minute) {
    var date = new Date(valueRef.current == null ? d : valueRef.current);
    onChange(new Date(date.setMinutes(minute)));
  }, [d, onChange]);
  var onSecondChange = (0, _react.useCallback)(function (second) {
    var date = new Date(valueRef.current == null ? d : valueRef.current);
    onChange(new Date(date.setSeconds(second)));
  }, [d, onChange]);
  var callbackMap = {
    hour: onHourChange,
    minute: onMinuteChange,
    second: onSecondChange
  };
  return /*#__PURE__*/_react.default.createElement("div", (0, _extends2.default)({
    className: (0, _classnames.default)(prefixCls, className)
  }, rest), mode.map(function (mode, i) {
    var steps = stepsArray[i];
    var value = valueArray[i];
    return /*#__PURE__*/_react.default.createElement(Scroller, {
      key: i,
      value: value,
      onChange: callbackMap[TypeMap[mode]],
      steps: steps,
      prefixCls: prefixCls,
      scrollTo: scrollTo
    });
  }));
};

var _default = /*#__PURE__*/(0, _react.memo)(Time);

exports.default = _default;