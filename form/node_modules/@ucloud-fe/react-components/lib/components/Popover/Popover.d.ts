export const Animation: string[];
export const Trigger: string[];
export const Placement: string[];
export default Popover;
export { prefixCls };
declare class Popover extends React.Component<any, any, any> {
    static propTypes: {
        /** 受控，控制弹出层展示 */
        visible: PropTypes.Requireable<boolean>;
        /** 非受控，是否默认展示弹出层 */
        defaultVisible: PropTypes.Requireable<boolean>;
        /** 弹出层显示隐藏时触发 */
        onVisibleChange: PropTypes.Requireable<(...args: any[]) => any>;
        /** 如何触发弹出层，focus 需要注意被包裹元素必须能触发 focus 事件，如链接、按钮、input 等 */
        trigger: PropTypes.Requireable<(string | null | undefined)[]>;
        /** 根据鼠标位置定位 */
        alignPoint: PropTypes.Requireable<boolean>;
        /** @ignore */
        showAction: PropTypes.Requireable<any[]>;
        /** @ignore */
        hideAction: PropTypes.Requireable<any[]>;
        /** 位置 */
        placement: PropTypes.Requireable<string>;
        /**
         * @ignore
         * 自定义定位配置
         */
        builtinPlacements: PropTypes.Requireable<object>;
        /** 自定义定位 */
        align: PropTypes.Requireable<object>;
        /** 尺寸自适应，'width', 'minWidth', 'height', 'minHeight' 或混合使用 */
        stretch: PropTypes.Requireable<(string | null | undefined)[]>;
        /** 弹出层内容 */
        popup: PropTypes.Requireable<PropTypes.ReactNodeLike>;
        /** 弹出层的类名 */
        popupClassName: PropTypes.Requireable<string>;
        /** 弹出层的样式 */
        popupStyle: PropTypes.Requireable<object>;
        /** 弹出层的 z-index */
        zIndex: PropTypes.Requireable<number>;
        /** 自定义弹出层容器 */
        getPopupContainer: PropTypes.Requireable<(...args: any[]) => any>;
        /** 是否使用最上层传入的安全容器，如果为 function，在没有找到安全容器时将会使用该 function 作为 getPopupContainer 的值 */
        forwardPopupContainer: PropTypes.Requireable<boolean | ((...args: any[]) => any)>;
        /**
         * @ignore
         * 自定义类名前缀
         */
        prefixCls: PropTypes.Requireable<string>;
        /** 需要对子元素进行定位，所以只接收一个有效 react 元素（不接收文本节点） */
        children: PropTypes.Validator<PropTypes.ReactElementLike>;
        /** 动画名称，slide-up 只支持上下方向的弹窗 */
        animation: PropTypes.Requireable<string>;
        /**
         * @ignore
         * 自定义动画
         */
        transitionName: PropTypes.Requireable<string>;
        /**
         * @ignore
         * 更新时强制重新定位
         */
        forceAlignWhenUpdate: PropTypes.Requireable<boolean>;
        /** 滚动时强制重新定位 */
        forceAlignWhenScroll: PropTypes.Requireable<boolean>;
        /** @ignore */
        className: PropTypes.Requireable<string>;
    };
    static defaultProps: {
        trigger: string[];
        showAction: never[];
        hideAction: never[];
        popupClassName: string;
        animation: string;
        popupStyle: {};
        defaultVisible: boolean;
        onVisibleChange(): void;
        placement: string;
        builtinPlacements: {
            topLeft: {
                points: string[];
                overflow: {};
                offset: number[];
                targetOffset: number[];
            };
            top: {
                points: string[];
                overflow: {};
                offset: number[];
                targetOffset: number[];
            };
            topRight: {
                points: string[];
                overflow: {};
                offset: number[];
                targetOffset: number[];
            };
            bottomLeft: {
                points: string[]; /** 如何触发弹出层，focus 需要注意被包裹元素必须能触发 focus 事件，如链接、按钮、input 等 */
                overflow: {};
                offset: number[];
                targetOffset: number[];
            }; /** 根据鼠标位置定位 */
            bottom: {
                points: string[];
                overflow: {};
                offset: number[];
                targetOffset: number[];
            }; /** 位置 */
            bottomRight: {
                points: string[];
                overflow: {};
                offset: number[];
                targetOffset: number[]; /** 自定义定位 */
            };
            leftTop: {
                points: string[];
                overflow: {};
                offset: number[];
                targetOffset: number[];
            };
            left: {
                points: string[];
                overflow: {};
                offset: number[];
                targetOffset: number[];
            };
            leftBottom: {
                points: string[];
                overflow: {};
                offset: number[];
                targetOffset: number[];
            };
            rightTop: {
                points: string[];
                overflow: {};
                offset: number[];
                targetOffset: number[];
            };
            right: {
                points: string[];
                overflow: {};
                offset: number[];
                targetOffset: number[];
            };
            rightBottom: {
                points: string[];
                overflow: {};
                offset: number[];
                targetOffset: number[];
            };
        };
        forceAlignWhenScroll: boolean;
        prefixCls: string;
    };
    static getDerivedStateFromProps(nextProps: any): {
        visible: any;
    } | null;
    constructor(props: any);
    state: {
        visible: any;
    };
    __scroll_lock: boolean;
    __scroll_bind: boolean;
    bindPopupWrap: (_ref: any) => void;
    popupWrap: any;
    onPopupWrapScroll: () => void;
    unlockScroll: _.DebouncedFunc<() => void>;
    onScroll: () => void;
    forceAlign: _.DebouncedFunc<() => void>;
    bindScroll: () => void;
    unbindScroll: () => void;
    updateScroll: () => void;
    componentDidMount: () => void;
    componentWillUnmount: () => void;
    componentDidUpdate: (prevProps: any) => void;
    onVisibleChange: (visible: any) => void;
    getPopup(): JSX.Element;
    getPopupDomNode(): any;
    saveTrigger: (node: any) => void;
    trigger: any;
    render(): JSX.Element;
}
import { prefixCls } from "./style";
import React from "react";
import _ from "lodash";
import PropTypes from "prop-types";
