import { useRef, useCallback } from 'react';

var useDragDrop = function (_a) {
    var onDragStart = _a.onDragStart, onDragEnter = _a.onDragEnter, onDragOver = _a.onDragOver, onDragLeave = _a.onDragLeave, onDragEnd = _a.onDragEnd, onDrop = _a.onDrop, effectAllowed = _a.effectAllowed, dropEffect = _a.dropEffect, ignoreChildEnterLeave = _a.ignoreChildEnterLeave, ignoreSelf = _a.ignoreSelf;
    var sourceDomRef = useRef(null);
    var prevTargetDomRef = useRef(null);
    var enterCounterRef = useRef(0);
    var checkEvent = useCallback(function (e) {
        if (!sourceDomRef.current)
            return false;
        if (ignoreSelf && sourceDomRef.current === e.currentTarget)
            return false;
        return true;
    }, [ignoreSelf]);
    var clean = useCallback(function () {
        sourceDomRef.current = null;
        prevTargetDomRef.current = null;
        enterCounterRef.current = 0;
    }, []);
    var handleDragStart = useCallback(function (e) {
        clean();
        sourceDomRef.current = e.currentTarget;
        e.dataTransfer.effectAllowed = effectAllowed;
        onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart(e.currentTarget);
    }, [clean, effectAllowed, onDragStart]);
    var handleDragEnd = useCallback(function (e) {
        onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(e.currentTarget);
        clean();
    }, [clean, onDragEnd]);
    var handleDragEnter = useCallback(function (e) {
        if (!checkEvent(e))
            return;
        e.dataTransfer.dropEffect = dropEffect;
        if (ignoreChildEnterLeave) {
            if (e.currentTarget === prevTargetDomRef.current) {
                enterCounterRef.current++;
            }
            else {
                enterCounterRef.current = 1;
                onDragEnter === null || onDragEnter === void 0 ? void 0 : onDragEnter(sourceDomRef.current, e.currentTarget);
            }
            prevTargetDomRef.current = e.currentTarget;
            return;
        }
        onDragEnter === null || onDragEnter === void 0 ? void 0 : onDragEnter(sourceDomRef.current, e.currentTarget);
    }, [checkEvent, dropEffect, ignoreChildEnterLeave, onDragEnter]);
    var handleDragOver = useCallback(function (e) {
        if (!checkEvent(e))
            return;
        e.preventDefault();
        e.dataTransfer.dropEffect = dropEffect;
        onDragOver === null || onDragOver === void 0 ? void 0 : onDragOver(sourceDomRef.current, e.currentTarget);
    }, [checkEvent, dropEffect, onDragOver]);
    var handleDragLeave = useCallback(function (e) {
        if (!checkEvent(e))
            return;
        if (ignoreChildEnterLeave && e.currentTarget === prevTargetDomRef.current) {
            enterCounterRef.current--;
            if (enterCounterRef.current <= 0) {
                onDragLeave === null || onDragLeave === void 0 ? void 0 : onDragLeave(sourceDomRef.current, e.currentTarget);
                prevTargetDomRef.current = null;
            }
            return;
        }
        onDragLeave === null || onDragLeave === void 0 ? void 0 : onDragLeave(sourceDomRef.current, e.currentTarget);
    }, [checkEvent, ignoreChildEnterLeave, onDragLeave]);
    var handleDrop = useCallback(function (e) {
        if (!checkEvent(e))
            return;
        onDrop === null || onDrop === void 0 ? void 0 : onDrop(sourceDomRef.current, e.currentTarget);
        clean();
    }, [checkEvent, clean, onDrop]);
    var sourceProps = {
        draggable: true,
        onDragStart: handleDragStart,
        onDragEnd: handleDragEnd
    };
    var targetProps = {
        onDragEnter: handleDragEnter,
        onDragOver: handleDragOver,
        onDragLeave: handleDragLeave,
        onDrop: handleDrop
    };
    return [sourceProps, targetProps];
};

export { useDragDrop as default };
//# sourceMappingURL=index.js.map
